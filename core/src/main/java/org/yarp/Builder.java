package org.yarp;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import org.jruby.ir.IRScope;
import org.jruby.ir.operands.Operand;
import org.jruby.util.ByteList;

// GENERATED BY Builder.java.erb
// @formatter:off
public class Builder {
    public enum TokenType {
        EOF,
        MISSING,
        NOT_PROVIDED,
        AMPERSAND,
        AMPERSAND_AMPERSAND,
        AMPERSAND_AMPERSAND_EQUAL,
        AMPERSAND_DOT,
        AMPERSAND_EQUAL,
        BACKTICK,
        BACK_REFERENCE,
        BANG,
        BANG_EQUAL,
        BANG_TILDE,
        BRACE_LEFT,
        BRACE_RIGHT,
        BRACKET_LEFT,
        BRACKET_LEFT_ARRAY,
        BRACKET_LEFT_RIGHT,
        BRACKET_LEFT_RIGHT_EQUAL,
        BRACKET_RIGHT,
        CARET,
        CARET_EQUAL,
        CHARACTER_LITERAL,
        CLASS_VARIABLE,
        COLON,
        COLON_COLON,
        COMMA,
        COMMENT,
        CONSTANT,
        DOT,
        DOT_DOT,
        DOT_DOT_DOT,
        EMBDOC_BEGIN,
        EMBDOC_END,
        EMBDOC_LINE,
        EMBEXPR_BEGIN,
        EMBEXPR_END,
        EMBVAR,
        EQUAL,
        EQUAL_EQUAL,
        EQUAL_EQUAL_EQUAL,
        EQUAL_GREATER,
        EQUAL_TILDE,
        FLOAT,
        GLOBAL_VARIABLE,
        GREATER,
        GREATER_EQUAL,
        GREATER_GREATER,
        GREATER_GREATER_EQUAL,
        HEREDOC_END,
        HEREDOC_START,
        IDENTIFIER,
        IGNORED_NEWLINE,
        IMAGINARY_NUMBER,
        INSTANCE_VARIABLE,
        INTEGER,
        KEYWORD_ALIAS,
        KEYWORD_AND,
        KEYWORD_BEGIN,
        KEYWORD_BEGIN_UPCASE,
        KEYWORD_BREAK,
        KEYWORD_CASE,
        KEYWORD_CLASS,
        KEYWORD_DEF,
        KEYWORD_DEFINED,
        KEYWORD_DO,
        KEYWORD_DO_LOOP,
        KEYWORD_ELSE,
        KEYWORD_ELSIF,
        KEYWORD_END,
        KEYWORD_END_UPCASE,
        KEYWORD_ENSURE,
        KEYWORD_FALSE,
        KEYWORD_FOR,
        KEYWORD_IF,
        KEYWORD_IF_MODIFIER,
        KEYWORD_IN,
        KEYWORD_MODULE,
        KEYWORD_NEXT,
        KEYWORD_NIL,
        KEYWORD_NOT,
        KEYWORD_OR,
        KEYWORD_REDO,
        KEYWORD_RESCUE,
        KEYWORD_RESCUE_MODIFIER,
        KEYWORD_RETRY,
        KEYWORD_RETURN,
        KEYWORD_SELF,
        KEYWORD_SUPER,
        KEYWORD_THEN,
        KEYWORD_TRUE,
        KEYWORD_UNDEF,
        KEYWORD_UNLESS,
        KEYWORD_UNLESS_MODIFIER,
        KEYWORD_UNTIL,
        KEYWORD_UNTIL_MODIFIER,
        KEYWORD_WHEN,
        KEYWORD_WHILE,
        KEYWORD_WHILE_MODIFIER,
        KEYWORD_YIELD,
        KEYWORD___ENCODING__,
        KEYWORD___FILE__,
        KEYWORD___LINE__,
        LABEL,
        LABEL_END,
        LAMBDA_BEGIN,
        LESS,
        LESS_EQUAL,
        LESS_EQUAL_GREATER,
        LESS_LESS,
        LESS_LESS_EQUAL,
        MINUS,
        MINUS_EQUAL,
        MINUS_GREATER,
        NEWLINE,
        NTH_REFERENCE,
        PARENTHESIS_LEFT,
        PARENTHESIS_LEFT_PARENTHESES,
        PARENTHESIS_RIGHT,
        PERCENT,
        PERCENT_EQUAL,
        PERCENT_LOWER_I,
        PERCENT_LOWER_W,
        PERCENT_LOWER_X,
        PERCENT_UPPER_I,
        PERCENT_UPPER_W,
        PIPE,
        PIPE_EQUAL,
        PIPE_PIPE,
        PIPE_PIPE_EQUAL,
        PLUS,
        PLUS_EQUAL,
        QUESTION_MARK,
        RATIONAL_NUMBER,
        REGEXP_BEGIN,
        REGEXP_END,
        SEMICOLON,
        SLASH,
        SLASH_EQUAL,
        STAR,
        STAR_EQUAL,
        STAR_STAR,
        STAR_STAR_EQUAL,
        STRING_BEGIN,
        STRING_CONTENT,
        STRING_END,
        SYMBOL_BEGIN,
        TILDE,
        UCOLON_COLON,
        UDOT_DOT,
        UDOT_DOT_DOT,
        UMINUS,
        UPLUS,
        USTAR,
        WORDS_SEP,
        __END__,
    }

    static final TokenType[] TOKEN_TYPES = TokenType.values();


    public static IRScope build(byte[] source, byte[] serialized) {
        return new Builder(source, serialized).build();
    }

    private final ByteBuffer buffer;
    private final byte[] source;

    private Builder(byte[] source, byte[] serialized) {
        this.source = source;
        buffer = ByteBuffer.wrap(serialized).order(ByteOrder.nativeOrder());
    }

    private IRScope build() {
        expect((byte) 'Y');
        expect((byte) 'A');
        expect((byte) 'R');
        expect((byte) 'P');

        expect((byte) 0);
        expect((byte) 4);
        expect((byte) 0);

        buildNode();
        return null;
}

// FIXME: Scope seems like it is unneeded locals can just be on the scopes which have locals        
// FIXME: how do parse errors work?
// FIXME: In most tokens the text is not used but the type is significant.  It would be nice to know which is which. locals are all ones where we just want strings.  DOT vs AMPERSAND_DOT we just need type.  I could just have LoadToken{,s} guess based on Type what it expects.  Thus far I see no token I would want to retain location info for.
// FIXME: chrono order is not always obeyed in node like Array has: elements, start,end.  Knowing array type first allows direct construction of symbols vs strings.  Is there a rule on ordering?
// FIXME: how do we ignore what we do not need for execution?
//   skipToken() can be done but I need to figure that out from the yaml
//     or maintain that list outside (example 1 && 2 I do not need to decode '&&' or 'and').

// LOL.
    // Represents the use of the `alias` keyword.
    // 
    //     alias foo bar
    //     ^^^^^^^^^^^^^
    public Operand buildAliasNode(int length, int startOffset, int endOffset) {
        Operand new_name = buildNode();
        Operand old_name = buildNode();
        buildLocation();

        return null;
    }
    // Represents the use of the `&&` operator or the `and` keyword.
    // 
    //     left and right
    //     ^^^^^^^^^^^^^^
    public Operand buildAndNode(int length, int startOffset, int endOffset) {
        Operand left = buildNode();
        Operand right = buildNode();
        Object operator = buildToken();

        return null;
    }
    // Represents a set of arguments to a method or a keyword.
    // 
    //     return foo, bar, baz
    //            ^^^^^^^^^^^^^
    public Operand buildArgumentsNode(int length, int startOffset, int endOffset) {
        Operand[] arguments = buildNodes();

        return null;
    }
    // Represents an array literal. This can be a regular array using brackets or
    // a special array using % like %w or %i.
    // 
    //     [1, 2, 3]
    //     ^^^^^^^^^
    public Operand buildArrayNode(int length, int startOffset, int endOffset) {
        Operand[] elements = buildNodes();
        Object opening = buildOptionalToken();
        Object closing = buildOptionalToken();

        return null;
    }
    // Represents a hash key/value pair.
    // 
    //     { a => b }
    //       ^^^^^^
    public Operand buildAssocNode(int length, int startOffset, int endOffset) {
        Operand key = buildNode();
        Operand value = buildOptionalNode();
        Object operator = buildOptionalToken();

        return null;
    }
    // Represents a splat in a hash literal.
    // 
    //     { **foo }
    //       ^^^^^
    public Operand buildAssocSplatNode(int length, int startOffset, int endOffset) {
        Operand value = buildNode();
        buildLocation();

        return null;
    }
    // Represents a begin statement.
    // 
    //     begin
    //       foo
    //     end
    //     ^^^^^
    public Operand buildBeginNode(int length, int startOffset, int endOffset) {
        Object begin_keyword = buildOptionalToken();
        Operand statements = buildNode();
        Operand rescue_clause = buildOptionalNode();
        Operand else_clause = buildOptionalNode();
        Operand ensure_clause = buildOptionalNode();
        Object end_keyword = buildOptionalToken();

        return null;
    }
    // Represents block method arguments.
    // 
    //     bar(&args)
    //     ^^^^^^^^^^
    public Operand buildBlockArgumentNode(int length, int startOffset, int endOffset) {
        Operand expression = buildNode();
        buildLocation();

        return null;
    }
    // Represents a block of ruby code.
    // 
    // [1, 2, 3].each { |i| puts x }
    //                ^^^^^^^^^^^^^^
    public Operand buildBlockNode(int length, int startOffset, int endOffset) {
        Operand parameters = buildOptionalNode();
        Operand statements = buildOptionalNode();
        buildLocation();
        buildLocation();

        return null;
    }
    // Represents a block parameter to a method, block, or lambda definition.
    // 
    //     def a(&b)
    //           ^^
    //     end
    public Operand buildBlockParameterNode(int length, int startOffset, int endOffset) {
        Object name = buildOptionalToken();
        buildLocation();

        return null;
    }
    // Represents a block variable declaration.
    // 
    //     -> (a, b = 1; local) { }
    //         ^^^^^^^^^^^^^^^
    public Operand buildBlockParametersNode(int length, int startOffset, int endOffset) {
        Operand parameters = buildNode();
        Object[] locals = buildTokens();

        return null;
    }
    // Represents the use of the `break` keyword.
    // 
    //     break foo
    //     ^^^^^^^^^
    public Operand buildBreakNode(int length, int startOffset, int endOffset) {
        Operand arguments = buildOptionalNode();
        buildLocation();

        return null;
    }
    // Represents a method call, in all of the various forms that that can take.
    // 
    //     foo
    //     ^^^
    // 
    //     +foo
    //     ^^^^
    // 
    //     foo + bar
    //     ^^^^^^^^^
    // 
    //     foo.bar
    //     ^^^^^^^
    public Operand buildCallNode(int length, int startOffset, int endOffset) {
        Operand receiver = buildOptionalNode();
        Object call_operator = buildOptionalToken();
        Object message = buildOptionalToken();
        Object opening = buildOptionalToken();
        Operand arguments = buildOptionalNode();
        Object closing = buildOptionalToken();
        Operand block = buildOptionalNode();
        Operand name = buildString();

        return null;
    }
    // Represents the use of a case statement.
    // 
    // case true
    // ^^^^^^^^^
    // when false
    // end
    public Operand buildCaseNode(int length, int startOffset, int endOffset) {
        Operand predicate = buildOptionalNode();
        Operand[] conditions = buildNodes();
        Operand consequent = buildOptionalNode();
        buildLocation();
        buildLocation();

        return null;
    }
    // Represents a class declaration involving the `class` keyword.
    // 
    //     class Foo end
    //     ^^^^^^^^^^^^^
    public Operand buildClassNode(int length, int startOffset, int endOffset) {
        Operand scope = buildNode();
        Object class_keyword = buildToken();
        Operand constant_path = buildNode();
        Object inheritance_operator = buildOptionalToken();
        Operand superclass = buildOptionalNode();
        Operand statements = buildNode();
        Object end_keyword = buildToken();

        return null;
    }
    // Represents referencing a class variable.
    // 
    //     @@foo
    //     ^^^^^
    public Operand buildClassVariableReadNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents writing to a class variable.
    // 
    //     @@foo = 1
    //     ^^^^^^^^^
    public Operand buildClassVariableWriteNode(int length, int startOffset, int endOffset) {
        buildLocation();
        Operand value = buildOptionalNode();
        buildOptionalLocation();

        return null;
    }
    // Represents accessing a constant through a path of `::` operators.
    // 
    //     Foo::Bar
    //     ^^^^^^^^
    public Operand buildConstantPathNode(int length, int startOffset, int endOffset) {
        Operand parent = buildOptionalNode();
        Object delimiter = buildToken();
        Operand child = buildNode();

        return null;
    }
    // Represents writing to a constant.
    // 
    //     Foo = 1
    //     ^^^^^^^
    // 
    //     Foo::Bar = 1
    //     ^^^^^^^^^^^^
    public Operand buildConstantPathWriteNode(int length, int startOffset, int endOffset) {
        Operand target = buildNode();
        Object operator = buildOptionalToken();
        Operand value = buildOptionalNode();

        return null;
    }
    // Represents referencing a constant.
    // 
    //     Foo
    //     ^^^
    public Operand buildConstantReadNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents a method definition.
    // 
    //     def method
    //     end
    //     ^^^^^^^^^^
    public Operand buildDefNode(int length, int startOffset, int endOffset) {
        Object name = buildToken();
        Operand receiver = buildOptionalNode();
        Operand parameters = buildNode();
        Operand statements = buildNode();
        Operand scope = buildNode();
        buildLocation();
        buildOptionalLocation();
        buildOptionalLocation();
        buildOptionalLocation();
        buildOptionalLocation();
        buildOptionalLocation();

        return null;
    }
    // Represents the use of the `defined?` keyword.
    // 
    //     defined?(a)
    //     ^^^^^^^^^^^
    public Operand buildDefinedNode(int length, int startOffset, int endOffset) {
        Object lparen = buildOptionalToken();
        Operand value = buildNode();
        Object rparen = buildOptionalToken();
        buildLocation();

        return null;
    }
    // Represents an `else` clause in a `case`, `if`, or `unless` statement.
    // 
    //     if a then b else c end
    //                 ^^^^^^^^^^
    public Operand buildElseNode(int length, int startOffset, int endOffset) {
        Object else_keyword = buildToken();
        Operand statements = buildOptionalNode();
        Object end_keyword = buildToken();

        return null;
    }
    // Represents an `ensure` clause in a `begin` statement.
    // 
    //     begin
    //       foo
    //     ensure
    //     ^^^^^^
    //       bar
    //     end
    public Operand buildEnsureNode(int length, int startOffset, int endOffset) {
        Object ensure_keyword = buildToken();
        Operand statements = buildNode();
        Object end_keyword = buildToken();

        return null;
    }
    // Represents the use of the literal `false` keyword.
    // 
    //     false
    //     ^^^^^
    public Operand buildFalseNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents a floating point number literal.
    // 
    //     1.0
    //     ^^^
    public Operand buildFloatNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents the use of the `for` keyword.
    // 
    //     for i in a end
    //     ^^^^^^^^^^^^^^
    public Operand buildForNode(int length, int startOffset, int endOffset) {
        Operand index = buildNode();
        Operand collection = buildNode();
        Operand statements = buildNode();
        buildLocation();
        buildLocation();
        buildOptionalLocation();
        buildLocation();

        return null;
    }
    // Represents forwarding all arguments to this method to another method.
    // 
    //     def foo(...)
    //       bar(...)
    //       ^^^^^^^^
    //     end
    public Operand buildForwardingArgumentsNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents the use of the forwarding parameter in a method, block, or lambda declaration.
    // 
    //     def foo(...)
    //             ^^^
    //     end
    public Operand buildForwardingParameterNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents the use of the `super` keyword without parentheses or arguments.
    // 
    //     super
    //     ^^^^^
    public Operand buildForwardingSuperNode(int length, int startOffset, int endOffset) {
        Operand block = buildOptionalNode();

        return null;
    }
    // Represents referencing a global variable.
    // 
    //     $foo
    //     ^^^^
    public Operand buildGlobalVariableReadNode(int length, int startOffset, int endOffset) {
        Object name = buildToken();

        return null;
    }
    // Represents writing to a global variable.
    // 
    //     $foo = 1
    //     ^^^^^^^^
    public Operand buildGlobalVariableWriteNode(int length, int startOffset, int endOffset) {
        Object name = buildToken();
        Object operator = buildOptionalToken();
        Operand value = buildOptionalNode();

        return null;
    }
    // Represents a hash literal.
    // 
    //     { a => b }
    //     ^^^^^^^^^^
    public Operand buildHashNode(int length, int startOffset, int endOffset) {
        Object opening = buildOptionalToken();
        Operand[] elements = buildNodes();
        Object closing = buildOptionalToken();

        return null;
    }
    // Represents the use of a heredoc.
    // 
    //     <<~HERE
    //       Content.
    //     HERE
    //     ^^^^^^^^^^
    public Operand buildHeredocNode(int length, int startOffset, int endOffset) {
        Object opening = buildToken();
        Operand[] parts = buildNodes();
        Object closing = buildToken();
        Operand dedent = buildInteger();

        return null;
    }
    // Represents the use of the `if` keyword, either in the block form or the modifier form.
    // 
    //     bar if foo
    //     ^^^^^^^^^^
    // 
    //     if foo then bar end
    //     ^^^^^^^^^^^^^^^^^^^
    public Operand buildIfNode(int length, int startOffset, int endOffset) {
        Object if_keyword = buildToken();
        Operand predicate = buildNode();
        Operand statements = buildNode();
        Operand consequent = buildOptionalNode();
        Object end_keyword = buildOptionalToken();

        return null;
    }
    // Represents an imaginary number literal.
    // 
    //     1.0i
    //     ^^^^
    public Operand buildImaginaryNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents referencing an instance variable.
    // 
    //     @foo
    //     ^^^^
    public Operand buildInstanceVariableReadNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents writing to an instance variable.
    // 
    //     @foo = 1
    //     ^^^^^^^^
    public Operand buildInstanceVariableWriteNode(int length, int startOffset, int endOffset) {
        buildLocation();
        Operand value = buildOptionalNode();
        buildOptionalLocation();

        return null;
    }
    // Represents an integer number literal.
    // 
    //     1
    //     ^
    public Operand buildIntegerNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents a regular expression literal that contains interpolation.
    // 
    //     /foo #{bar} baz/
    //     ^^^^^^^^^^^^^^^^
    public Operand buildInterpolatedRegularExpressionNode(int length, int startOffset, int endOffset) {
        Object opening = buildToken();
        Operand[] parts = buildNodes();
        Object closing = buildToken();

        return null;
    }
    // Represents a string literal that contains interpolation.
    // 
    //     "foo #{bar} baz"
    //     ^^^^^^^^^^^^^^^^
    public Operand buildInterpolatedStringNode(int length, int startOffset, int endOffset) {
        Object opening = buildOptionalToken();
        Operand[] parts = buildNodes();
        Object closing = buildOptionalToken();

        return null;
    }
    // Represents a symbol literal that contains interpolation.
    // 
    //     :"foo #{bar} baz"
    //     ^^^^^^^^^^^^^^^^^
    public Operand buildInterpolatedSymbolNode(int length, int startOffset, int endOffset) {
        Object opening = buildOptionalToken();
        Operand[] parts = buildNodes();
        Object closing = buildOptionalToken();

        return null;
    }
    // Represents an xstring literal that contains interpolation.
    // 
    //     `foo #{bar} baz`
    //     ^^^^^^^^^^^^^^^^
    public Operand buildInterpolatedXStringNode(int length, int startOffset, int endOffset) {
        Object opening = buildToken();
        Operand[] parts = buildNodes();
        Object closing = buildToken();

        return null;
    }
    // Represents a keyword parameter to a method, block, or lambda definition.
    // 
    //     def a(b:)
    //           ^^
    //     end
    // 
    //     def a(b: 1)
    //           ^^^^
    //     end
    public Operand buildKeywordParameterNode(int length, int startOffset, int endOffset) {
        Object name = buildToken();
        Operand value = buildOptionalNode();

        return null;
    }
    // Represents a keyword rest parameter to a method, block, or lambda definition.
    // 
    //     def a(**b)
    //           ^^^
    //     end
    public Operand buildKeywordRestParameterNode(int length, int startOffset, int endOffset) {
        Object operator = buildToken();
        Object name = buildOptionalToken();

        return null;
    }
    // Represents keyword splat method arguments.
    // 
    //     bar(**kwargs)
    //     ^^^^^^^^^^^
    public Operand buildKeywordStarNode(int length, int startOffset, int endOffset) {
        Object operator = buildToken();
        Operand expression = buildNode();

        return null;
    }
    // Represents using a lambda literal (not the lambda method call).
    // 
    //     ->(value) { value * 2 }
    //     ^^^^^^^^^^^^^^^^^^^^^^^
    public Operand buildLambdaNode(int length, int startOffset, int endOffset) {
        Operand scope = buildNode();
        Object lparen = buildOptionalToken();
        Operand parameters = buildNode();
        Object rparen = buildOptionalToken();
        Operand statements = buildNode();

        return null;
    }
    // Represents reading a local variable. Note that this requires that a local
    // variable of the same name has already been written to in the same scope,
    // otherwise it is parsed as a method call.
    // 
    //     foo
    //     ^^^
    public Operand buildLocalVariableReadNode(int length, int startOffset, int endOffset) {
        Object name = buildToken();

        return null;
    }
    // Represents writing to a local variable.
    // 
    //     foo = 1
    //     ^^^^^^^
    public Operand buildLocalVariableWriteNode(int length, int startOffset, int endOffset) {
        Object name = buildToken();
        Object operator = buildOptionalToken();
        Operand value = buildOptionalNode();

        return null;
    }
    // Represents a node that is missing from the source and results in a syntax
    // error.
    public Operand buildMissingNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents a module declaration involving the `module` keyword.
    // 
    //     module Foo end
    //     ^^^^^^^^^^^^^^
    public Operand buildModuleNode(int length, int startOffset, int endOffset) {
        Operand scope = buildNode();
        Object module_keyword = buildToken();
        Operand constant_path = buildNode();
        Operand statements = buildNode();
        Object end_keyword = buildToken();

        return null;
    }
    // Represents a multi-target expression.
    // 
    //     a, b, c = 1, 2, 3
    //     ^^^^^^^^^^^^^^^^^
    public Operand buildMultiWriteNode(int length, int startOffset, int endOffset) {
        Operand[] targets = buildNodes();
        Object operator = buildOptionalToken();
        Operand value = buildOptionalNode();
        buildOptionalLocation();
        buildOptionalLocation();

        return null;
    }
    // Represents the use of the `next` keyword.
    // 
    //     next 1
    //     ^^^^^^
    public Operand buildNextNode(int length, int startOffset, int endOffset) {
        Operand arguments = buildOptionalNode();
        buildLocation();

        return null;
    }
    // Represents the use of the `nil` keyword.
    // 
    //     nil
    //     ^^^
    public Operand buildNilNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents the use of `**nil` inside method arguments.
    // 
    //     def a(**nil)
    //           ^^^^^
    //     end
    public Operand buildNoKeywordsParameterNode(int length, int startOffset, int endOffset) {
        buildLocation();
        buildLocation();

        return null;
    }
    // Represents the use of the `&&=` operator for assignment.
    // 
    //     target &&= value
    //     ^^^^^^^^^^^^^^^^
    public Operand buildOperatorAndAssignmentNode(int length, int startOffset, int endOffset) {
        Operand target = buildNode();
        Operand value = buildNode();
        buildLocation();

        return null;
    }
    // Represents assigning to a value using an operator that isn't `=`.
    // 
    //     foo += bar
    //     ^^^^^^^^^^
    public Operand buildOperatorAssignmentNode(int length, int startOffset, int endOffset) {
        Operand target = buildNode();
        Object operator = buildToken();
        Operand value = buildNode();

        return null;
    }
    // Represents the use of the `||=` operator for assignment.
    // 
    //     target ||= value
    //     ^^^^^^^^^^^^^^^^
    public Operand buildOperatorOrAssignmentNode(int length, int startOffset, int endOffset) {
        Operand target = buildNode();
        Operand value = buildNode();
        buildLocation();

        return null;
    }
    // Represents an optional parameter to a method, block, or lambda definition.
    // 
    //     def a(b = 1)
    //           ^^^^^
    //     end
    public Operand buildOptionalParameterNode(int length, int startOffset, int endOffset) {
        Object name = buildToken();
        Object equal_operator = buildToken();
        Operand value = buildNode();

        return null;
    }
    // Represents the use of the `||` operator or the `or` keyword.
    // 
    //     left or right
    //     ^^^^^^^^^^^^^
    public Operand buildOrNode(int length, int startOffset, int endOffset) {
        Operand left = buildNode();
        Operand right = buildNode();
        buildLocation();

        return null;
    }
    // Represents the list of parameters on a method, block, or lambda definition.
    // 
    //     def a(b, c, d)
    //           ^^^^^^^
    //     end
    public Operand buildParametersNode(int length, int startOffset, int endOffset) {
        Operand[] requireds = buildNodes();
        Operand[] optionals = buildNodes();
        Operand rest = buildOptionalNode();
        Operand[] keywords = buildNodes();
        Operand keyword_rest = buildOptionalNode();
        Operand block = buildOptionalNode();

        return null;
    }
    // Represents a parentesized expression
    // 
    //     (10 + 34)
    //     ^^^^^^^^^
    public Operand buildParenthesesNode(int length, int startOffset, int endOffset) {
        Operand statements = buildOptionalNode();
        buildLocation();
        buildLocation();

        return null;
    }
    // Represents the use of the `END` keyword.
    // 
    //     BEGIN { foo }
    //     ^^^^^^^^^^^^^
    public Operand buildPostExecutionNode(int length, int startOffset, int endOffset) {
        Operand statements = buildNode();
        buildLocation();
        buildLocation();
        buildLocation();

        return null;
    }
    // Represents the use of the `END` keyword.
    // 
    //     END { foo }
    //     ^^^^^^^^^^^
    public Operand buildPreExecutionNode(int length, int startOffset, int endOffset) {
        Operand statements = buildNode();
        buildLocation();
        buildLocation();
        buildLocation();

        return null;
    }
    // The top level node of any parse tree.
    public Operand buildProgramNode(int length, int startOffset, int endOffset) {
        Operand scope = buildNode();
        Operand statements = buildNode();

        return null;
    }
    // Represents the use of the `..` or `...` operators.
    // 
    //     1..2
    //     ^^^^
    // 
    //     c if a =~ /left/ ... b =~ /right/
    //          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    public Operand buildRangeNode(int length, int startOffset, int endOffset) {
        Operand left = buildOptionalNode();
        Operand right = buildOptionalNode();
        buildLocation();

        return null;
    }
    // Represents a rational number literal.
    // 
    //     1.0r
    //     ^^^^
    public Operand buildRationalNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents the use of the `redo` keyword.
    // 
    //     redo
    //     ^^^^
    public Operand buildRedoNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents a regular expression literal with no interpolation.
    // 
    //     /foo/i
    //     ^^^^^^
    public Operand buildRegularExpressionNode(int length, int startOffset, int endOffset) {
        Object opening = buildToken();
        Object content = buildToken();
        Object closing = buildToken();
        Operand unescaped = buildString();

        return null;
    }
    // Represents a destructured required parameter node.
    // 
    //     def foo((bar, baz))
    //             ^^^^^^^^^^
    //     end
    public Operand buildRequiredDestructuredParameterNode(int length, int startOffset, int endOffset) {
        Operand[] parameters = buildNodes();
        Object opening = buildToken();
        Object closing = buildToken();

        return null;
    }
    // Represents a required parameter to a method, block, or lambda definition.
    // 
    //     def a(b)
    //           ^
    //     end
    public Operand buildRequiredParameterNode(int length, int startOffset, int endOffset) {
        Object name = buildToken();

        return null;
    }
    // Represents an expression modified with a rescue.
    // 
    //   foo rescue nil
    //   ^^^^^^^^^^^^^^
    public Operand buildRescueModifierNode(int length, int startOffset, int endOffset) {
        Operand expression = buildNode();
        Object rescue_keyword = buildToken();
        Operand rescue_expression = buildNode();

        return null;
    }
    // Represents a rescue statement.
    // 
    //     begin
    //     rescue
    //       foo
    //     ^^^^^^
    //     end
    public Operand buildRescueNode(int length, int startOffset, int endOffset) {
        Object rescue_keyword = buildToken();
        Operand[] exceptions = buildNodes();
        Object equal_greater = buildOptionalToken();
        Operand exception = buildOptionalNode();
        Operand statements = buildNode();
        Operand consequent = buildOptionalNode();

        return null;
    }
    // Represents a rest parameter to a method, block, or lambda definition.
    // 
    //     def a(*b)
    //           ^^
    //     end
    public Operand buildRestParameterNode(int length, int startOffset, int endOffset) {
        Object operator = buildToken();
        Object name = buildOptionalToken();

        return null;
    }
    // Represents the use of the `retry` keyword.
    // 
    //     retry
    //     ^^^^^
    public Operand buildRetryNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents the use of the `return` keyword.
    // 
    //     return 1
    //     ^^^^^^^^
    public Operand buildReturnNode(int length, int startOffset, int endOffset) {
        Object keyword = buildToken();
        Operand arguments = buildOptionalNode();

        return null;
    }
    // Represents the local variables within a given lexical scope. These are
    // attached to nodes where a new scope is created.
    public Operand buildScope(int length, int startOffset, int endOffset) {
        Object[] locals = buildTokens();

        return null;
    }
    // Represents the `self` keyword.
    // 
    //     self
    //     ^^^^
    public Operand buildSelfNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents a singleton class declaration involving the `class` keyword.
    // 
    //     class << self end
    //     ^^^^^^^^^^^^^^^^^
    public Operand buildSingletonClassNode(int length, int startOffset, int endOffset) {
        Operand scope = buildNode();
        Object class_keyword = buildToken();
        Object operator = buildToken();
        Operand expression = buildNode();
        Operand statements = buildNode();
        Object end_keyword = buildToken();

        return null;
    }
    // Represents the use of the `__ENCODING__` keyword.
    // 
    //     __ENCODING__
    //     ^^^^^^^^^^^^
    public Operand buildSourceEncodingNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents the use of the `__FILE__` keyword.
    // 
    //     __FILE__
    //     ^^^^^^^^
    public Operand buildSourceFileNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents the use of the `__LINE__` keyword.
    // 
    //     __LINE__
    //     ^^^^^^^^
    public Operand buildSourceLineNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents the use of the splat operator.
    // 
    //     [*a]
    //      ^^
    public Operand buildSplatNode(int length, int startOffset, int endOffset) {
        Object operator = buildToken();
        Operand expression = buildOptionalNode();

        return null;
    }
    // Represents a set of statements contained within some scope.
    // 
    //     foo; bar; baz
    //     ^^^^^^^^^^^^^
    public Operand buildStatementsNode(int length, int startOffset, int endOffset) {
        Operand[] body = buildNodes();

        return null;
    }
    // Represents the use of compile-time string concatenation.
    // 
    //     "foo" "bar"
    //     ^^^^^^^^^^^
    public Operand buildStringConcatNode(int length, int startOffset, int endOffset) {
        Operand left = buildNode();
        Operand right = buildNode();

        return null;
    }
    // Represents an interpolated set of statements within a string.
    // 
    //     "foo #{bar}"
    //          ^^^^^^
    public Operand buildStringInterpolatedNode(int length, int startOffset, int endOffset) {
        Object opening = buildToken();
        Operand statements = buildNode();
        Object closing = buildToken();

        return null;
    }
    // Represents a string literal, a string contained within a `%w` list, or
    // plain string content within an interpolated string.
    // 
    //     "foo"
    //     ^^^^^
    // 
    //     %w[foo]
    //        ^^^
    // 
    //     "foo #{bar} baz"
    //      ^^^^      ^^^^
    public Operand buildStringNode(int length, int startOffset, int endOffset) {
        Object opening = buildOptionalToken();
        Object content = buildToken();
        Object closing = buildOptionalToken();
        Operand unescaped = buildString();

        return null;
    }
    // Represents the use of the `super` keyword with parentheses or arguments.
    // 
    //     super()
    //     ^^^^^^^
    // 
    //     super foo, bar
    //     ^^^^^^^^^^^^^^
    public Operand buildSuperNode(int length, int startOffset, int endOffset) {
        Object keyword = buildToken();
        Object lparen = buildOptionalToken();
        Operand arguments = buildOptionalNode();
        Object rparen = buildOptionalToken();
        Operand block = buildOptionalNode();

        return null;
    }
    // Represents a symbol literal or a symbol contained within a `%i` list.
    // 
    //     :foo
    //     ^^^^
    // 
    //     %i[foo]
    //        ^^^
    public Operand buildSymbolNode(int length, int startOffset, int endOffset) {
        Object opening = buildOptionalToken();
        Object value = buildToken();
        Object closing = buildOptionalToken();
        Operand unescaped = buildString();

        return null;
    }
    // Represents the use of the ternary operators.
    // 
    //     foo ? bar : baz
    //     ^^^^^^^^^^^^^^^
    public Operand buildTernaryNode(int length, int startOffset, int endOffset) {
        Operand predicate = buildNode();
        Object question_mark = buildToken();
        Operand true_expression = buildNode();
        Object colon = buildToken();
        Operand false_expression = buildNode();

        return null;
    }
    // Represents the use of the literal `true` keyword.
    // 
    //     true
    //     ^^^^
    public Operand buildTrueNode(int length, int startOffset, int endOffset) {
        ;

        return null;
    }
    // Represents the use of the `undef` keyword.
    // 
    //     undef :foo, :bar, :baz
    //     ^^^^^^^^^^^^^^^^^^^^^^
    public Operand buildUndefNode(int length, int startOffset, int endOffset) {
        Operand[] names = buildNodes();
        buildLocation();

        return null;
    }
    // Represents the use of the `unless` keyword, either in the block form or the modifier form.
    // 
    //     bar unless foo
    //     ^^^^^^^^^^^^^^
    // 
    //     unless foo then bar end
    //     ^^^^^^^^^^^^^^^^^^^^^^^
    public Operand buildUnlessNode(int length, int startOffset, int endOffset) {
        Object keyword = buildToken();
        Operand predicate = buildNode();
        Operand statements = buildNode();
        Operand consequent = buildOptionalNode();
        Object end_keyword = buildOptionalToken();

        return null;
    }
    // Represents the use of the `until` keyword, either in the block form or the modifier form.
    // 
    //     bar until foo
    //     ^^^^^^^^^^^^^
    // 
    //     until foo do bar end
    //     ^^^^^^^^^^^^^^^^^^^^
    public Operand buildUntilNode(int length, int startOffset, int endOffset) {
        Object keyword = buildToken();
        Operand predicate = buildNode();
        Operand statements = buildNode();

        return null;
    }
    // case true
    // when true
    // ^^^^^^^^^
    // end
    public Operand buildWhenNode(int length, int startOffset, int endOffset) {
        Object when_keyword = buildToken();
        Operand[] conditions = buildNodes();
        Operand statements = buildOptionalNode();

        return null;
    }
    // Represents the use of the `while` keyword, either in the block form or the modifier form.
    // 
    //     bar while foo
    //     ^^^^^^^^^^^^^
    // 
    //     while foo do bar end
    //     ^^^^^^^^^^^^^^^^^^^^
    public Operand buildWhileNode(int length, int startOffset, int endOffset) {
        Object keyword = buildToken();
        Operand predicate = buildNode();
        Operand statements = buildNode();

        return null;
    }
    // Represents an xstring literal with no interpolation.
    // 
    //     `foo`
    //     ^^^^^
    public Operand buildXStringNode(int length, int startOffset, int endOffset) {
        Object opening = buildToken();
        Object content = buildToken();
        Object closing = buildToken();
        Operand unescaped = buildString();

        return null;
    }
    // Represents the use of the `yield` keyword.
    // 
    //     yield 1
    //     ^^^^^^^
    public Operand buildYieldNode(int length, int startOffset, int endOffset) {
        Object keyword = buildToken();
        Object lparen = buildOptionalToken();
        Operand arguments = buildOptionalNode();
        Object rparen = buildOptionalToken();

        return null;
    }



    private Operand buildString() {
// FIXME: How do we know encoding for file?
// FIXME: How do we know this is frozen or not?
        int length = buffer.getInt();
        byte[] string = new byte[length];
        buffer.get(string);
        return null;
    }

    private Object buildOptionalToken() {
        if (buffer.get(buffer.position()) != 0) {
            return buildToken();
        } else {
            buffer.position(buffer.position() + 1); // continue after the 0 byte
            return null;
        }
    }

    private Operand buildOptionalNode() {
        if (buffer.get(buffer.position()) != 0) {
            return buildNode();
        } else {
            buffer.position(buffer.position() + 1); // continue after the 0 byte
            return null;
        }
    }

    private Object[] buildTokens() {
        // FIXME: consider how to unbox (blue blue sky since we box today)
        int length = buffer.getInt();
        Object[] tokens = new Object[length];
        for (int i = 0; i < length; i++) {
            tokens[i] = buildToken();
        }
        return tokens;
    }

    private Operand[] buildNodes() {
        int length = buffer.getInt();
        Operand[] nodes = new Operand[length];
        for (int i = 0; i < length; i++) {
            nodes[i] = buildNode();
        }
        return nodes;
    }

// FIXME: this is not COWing identifiers but it could which would kill arraycopy.  Not sure if that is a good idea or a horrible one.
                            
    private Object buildToken() {
        int type = buffer.get() & 0xFF;
        int startOffset = buffer.getInt();
        int endOffset = buffer.getInt();

        switch(Nodes.TOKEN_TYPES[type]) {
          case IDENTIFIER: {
              int length = endOffset - startOffset;
              byte[] id = new byte[length];
              System.arraycopy(source, startOffset, id, 0, length);
              return new ByteList(id); // FIXME: encoding missing.
          }
        }
       
        return null;  // We don't care about this token.
    }

    // FIXME: how are newline nodes known and how about linenumber itself?
    private Object buildLocation() {
        int startOffset = buffer.getInt();
        int endOffset = buffer.getInt();
        return null;
    }

    private Object buildOptionalLocation() {
        if (buffer.get(buffer.position()) != 0) {
            return buildLocation();
        } else {
            buffer.position(buffer.position() + 1); // continue after the 0 byte
            return null;
        }
    }

    private Operand buildInteger() {
                            //        return buffer.getInt();
        return null;
    }

    private Operand buildNode() {
        int type = buffer.get() & 0xFF;
        int length = buffer.getInt();
        int startOffset = buffer.getInt();
        int endOffset = buffer.getInt();

        switch (type) {
            case 0:
                return buildAliasNode(type, length, startOffset);
            case 1:
                return buildAndNode(type, length, startOffset);
            case 2:
                return buildArgumentsNode(type, length, startOffset);
            case 3:
                return buildArrayNode(type, length, startOffset);
            case 4:
                return buildAssocNode(type, length, startOffset);
            case 5:
                return buildAssocSplatNode(type, length, startOffset);
            case 6:
                return buildBeginNode(type, length, startOffset);
            case 7:
                return buildBlockArgumentNode(type, length, startOffset);
            case 8:
                return buildBlockNode(type, length, startOffset);
            case 9:
                return buildBlockParameterNode(type, length, startOffset);
            case 10:
                return buildBlockParametersNode(type, length, startOffset);
            case 11:
                return buildBreakNode(type, length, startOffset);
            case 12:
                return buildCallNode(type, length, startOffset);
            case 13:
                return buildCaseNode(type, length, startOffset);
            case 14:
                return buildClassNode(type, length, startOffset);
            case 15:
                return buildClassVariableReadNode(type, length, startOffset);
            case 16:
                return buildClassVariableWriteNode(type, length, startOffset);
            case 17:
                return buildConstantPathNode(type, length, startOffset);
            case 18:
                return buildConstantPathWriteNode(type, length, startOffset);
            case 19:
                return buildConstantReadNode(type, length, startOffset);
            case 20:
                return buildDefNode(type, length, startOffset);
            case 21:
                return buildDefinedNode(type, length, startOffset);
            case 22:
                return buildElseNode(type, length, startOffset);
            case 23:
                return buildEnsureNode(type, length, startOffset);
            case 24:
                return buildFalseNode(type, length, startOffset);
            case 25:
                return buildFloatNode(type, length, startOffset);
            case 26:
                return buildForNode(type, length, startOffset);
            case 27:
                return buildForwardingArgumentsNode(type, length, startOffset);
            case 28:
                return buildForwardingParameterNode(type, length, startOffset);
            case 29:
                return buildForwardingSuperNode(type, length, startOffset);
            case 30:
                return buildGlobalVariableReadNode(type, length, startOffset);
            case 31:
                return buildGlobalVariableWriteNode(type, length, startOffset);
            case 32:
                return buildHashNode(type, length, startOffset);
            case 33:
                return buildHeredocNode(type, length, startOffset);
            case 34:
                return buildIfNode(type, length, startOffset);
            case 35:
                return buildImaginaryNode(type, length, startOffset);
            case 36:
                return buildInstanceVariableReadNode(type, length, startOffset);
            case 37:
                return buildInstanceVariableWriteNode(type, length, startOffset);
            case 38:
                return buildIntegerNode(type, length, startOffset);
            case 39:
                return buildInterpolatedRegularExpressionNode(type, length, startOffset);
            case 40:
                return buildInterpolatedStringNode(type, length, startOffset);
            case 41:
                return buildInterpolatedSymbolNode(type, length, startOffset);
            case 42:
                return buildInterpolatedXStringNode(type, length, startOffset);
            case 43:
                return buildKeywordParameterNode(type, length, startOffset);
            case 44:
                return buildKeywordRestParameterNode(type, length, startOffset);
            case 45:
                return buildKeywordStarNode(type, length, startOffset);
            case 46:
                return buildLambdaNode(type, length, startOffset);
            case 47:
                return buildLocalVariableReadNode(type, length, startOffset);
            case 48:
                return buildLocalVariableWriteNode(type, length, startOffset);
            case 49:
                return buildMissingNode(type, length, startOffset);
            case 50:
                return buildModuleNode(type, length, startOffset);
            case 51:
                return buildMultiWriteNode(type, length, startOffset);
            case 52:
                return buildNextNode(type, length, startOffset);
            case 53:
                return buildNilNode(type, length, startOffset);
            case 54:
                return buildNoKeywordsParameterNode(type, length, startOffset);
            case 55:
                return buildOperatorAndAssignmentNode(type, length, startOffset);
            case 56:
                return buildOperatorAssignmentNode(type, length, startOffset);
            case 57:
                return buildOperatorOrAssignmentNode(type, length, startOffset);
            case 58:
                return buildOptionalParameterNode(type, length, startOffset);
            case 59:
                return buildOrNode(type, length, startOffset);
            case 60:
                return buildParametersNode(type, length, startOffset);
            case 61:
                return buildParenthesesNode(type, length, startOffset);
            case 62:
                return buildPostExecutionNode(type, length, startOffset);
            case 63:
                return buildPreExecutionNode(type, length, startOffset);
            case 64:
                return buildProgramNode(type, length, startOffset);
            case 65:
                return buildRangeNode(type, length, startOffset);
            case 66:
                return buildRationalNode(type, length, startOffset);
            case 67:
                return buildRedoNode(type, length, startOffset);
            case 68:
                return buildRegularExpressionNode(type, length, startOffset);
            case 69:
                return buildRequiredDestructuredParameterNode(type, length, startOffset);
            case 70:
                return buildRequiredParameterNode(type, length, startOffset);
            case 71:
                return buildRescueModifierNode(type, length, startOffset);
            case 72:
                return buildRescueNode(type, length, startOffset);
            case 73:
                return buildRestParameterNode(type, length, startOffset);
            case 74:
                return buildRetryNode(type, length, startOffset);
            case 75:
                return buildReturnNode(type, length, startOffset);
            case 76:
                return buildScope(type, length, startOffset);
            case 77:
                return buildSelfNode(type, length, startOffset);
            case 78:
                return buildSingletonClassNode(type, length, startOffset);
            case 79:
                return buildSourceEncodingNode(type, length, startOffset);
            case 80:
                return buildSourceFileNode(type, length, startOffset);
            case 81:
                return buildSourceLineNode(type, length, startOffset);
            case 82:
                return buildSplatNode(type, length, startOffset);
            case 83:
                return buildStatementsNode(type, length, startOffset);
            case 84:
                return buildStringConcatNode(type, length, startOffset);
            case 85:
                return buildStringInterpolatedNode(type, length, startOffset);
            case 86:
                return buildStringNode(type, length, startOffset);
            case 87:
                return buildSuperNode(type, length, startOffset);
            case 88:
                return buildSymbolNode(type, length, startOffset);
            case 89:
                return buildTernaryNode(type, length, startOffset);
            case 90:
                return buildTrueNode(type, length, startOffset);
            case 91:
                return buildUndefNode(type, length, startOffset);
            case 92:
                return buildUnlessNode(type, length, startOffset);
            case 93:
                return buildUntilNode(type, length, startOffset);
            case 94:
                return buildWhenNode(type, length, startOffset);
            case 95:
                return buildWhileNode(type, length, startOffset);
            case 96:
                return buildXStringNode(type, length, startOffset);
            case 97:
                return buildYieldNode(type, length, startOffset);
            default:
                throw new Error("Unknown node type: " + type);
        }
    }

    private void expect(byte value) {
        byte b = buffer.get();
        if (b != value) {
            throw new Error("Expected " + value + " but was " + b + " at position " + buffer.position());
        }
    }

}
// @formatter:on
